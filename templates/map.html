<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Interactive Map (Client-side state)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --bar-bg: #f8f8f8;
            --bar-bd: #ddd;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        }

        .toolbar {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bar-bg);
            border-bottom: 1px solid var(--bar-bd);
            padding: 8px 12px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #ccc;
            background: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }

        .btn:active {
            transform: translateY(1px);
        }

        #map-container {
            width: 100%;
            height: calc(100vh - 52px);
            overflow: hidden;
            position: relative;
        }

        #map-container svg {
            width: 100%;
            height: 100%;
            display: block;
            transform-origin: 0 0;
            touch-action: none;
        }

        .hint {
            color: #666;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div class="toolbar">
        <label>Color: <input type="color" id="color" value="#ff0000"></label>
        <button class="btn" id="resetBtn">Reset</button>
        <button class="btn" id="downloadBtn">Download JSON</button>
        <label class="btn">
            Load JSON<input type="file" id="uploadJson" accept="application/json" style="display:none">
        </label>
        <button class="btn" id="zoomInBtn">Zoom +</button>
        <button class="btn" id="zoomOutBtn">Zoom –</button>
        <button class="btn" id="resetViewBtn">Reset View</button>
        <span class="hint" id="status">Loading…</span>
    </div>

    <div id="map-container" aria-busy="true">Loading…</div>

    <script>
        (async function () {
            const $ = sel => document.querySelector(sel);
            const container = $('#map-container');
            const statusEl = $('#status');
            const colorEl = $('#color');
            const resetBtn = $('#resetBtn');
            const downloadBtn = $('#downloadBtn');
            const uploadInput = $('#uploadJson');
            const zoomInBtn = $('#zoomInBtn');
            const zoomOutBtn = $('#zoomOutBtn');
            const resetViewBtn = $('#resetViewBtn');

            const CSS_escape = (window.CSS && CSS.escape) ? CSS.escape : (s) => String(s).replace(/[^a-zA-Z0-9_-]/g, '\\$&');

            let defaults = {};
            let state = {};
            let svgRoot = null;

            let zoom = 1;
            let panX = 0;
            let panY = 0;
            let isDragging = false;
            let dragStart = null;

            function setStatus(txt) { statusEl.textContent = txt; }

            function applyTransform() {
                if (svgRoot) {
                    svgRoot.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
                }
            }

            function changeZoom(factor, cx = container.clientWidth / 2, cy = container.clientHeight / 2) {
                const oldZoom = zoom;
                zoom *= factor;
                panX = cx - (cx - panX) * (zoom / oldZoom);
                panY = cy - (cy - panY) * (zoom / oldZoom);
                applyTransform();
            }

            function applyFill(target, color) {
                if (!target) return;
                const tag = target.tagName.toLowerCase();
                if (tag === 'g') {
                    target.querySelectorAll('path, polygon, rect, circle, ellipse').forEach(n => {
                        n.setAttribute('fill', color);
                        n.style.fill = color;
                    });
                } else {
                    target.setAttribute('fill', color);
                    target.style.fill = color;
                }
            }

            function resolveKey(el) {
                if (!el) return null;
                if (el.dataset.key) return el.dataset.key;
                if (el.id) return el.id;
                const iso = el.getAttribute && (el.getAttribute('data-iso') || el.getAttribute('iso_a2'));
                if (iso) return iso;
                const nameAttr = el.getAttribute && (el.getAttribute('data-name') || el.getAttribute('name'));
                if (nameAttr) return nameAttr;
                const t = el.querySelector && el.querySelector('title');
                if (t && t.textContent) return t.textContent.trim();
                const g = el.closest && el.closest('[id]');
                if (g && g.id) return g.id;
                return null;
            }

            function paintFromState(root, dataObj) {
                for (const [id, color] of Object.entries(dataObj)) {
                    const el = root.querySelector('#' + CSS_escape(id)) || root.querySelector(`[data-iso="${id}"], [iso_a2="${id}"]`);
                    if (el) applyFill(el, color);
                }
            }

            function attachPaintHandlers(root) {
                const paintables = root.querySelectorAll('path, polygon, rect, circle, ellipse, g');
                paintables.forEach(el => {
                    const key = resolveKey(el);
                    if (!key) return;
                    el.dataset.key = key;
                    el.style.cursor = 'pointer';
                    el.addEventListener('click', (ev) => {
                        const target = ev.target.closest('[data-key]') || el;
                        const regionKey = target.dataset.key || resolveKey(target);
                        if (!regionKey) return;
                        const newColor = colorEl.value;
                        applyFill(target, newColor);
                        state[regionKey] = newColor;
                        setStatus(`Set ${regionKey} = ${newColor}`);
                    });
                });
            }

            async function loadDefaultsAndSvg() {
                setStatus('Loading defaults & SVG…');
                const [dataRes, svgRes] = await Promise.all([
                    fetch('/map-data', { cache: 'no-store' }),
                    fetch('/static/map/world.svg', { cache: 'no-store' })
                ]);
                if (!dataRes.ok) throw new Error('/map-data failed: ' + dataRes.status);
                if (!svgRes.ok) throw new Error('world.svg failed: ' + svgRes.status);

                defaults = await dataRes.json();
                state = structuredClone ? structuredClone(defaults) : JSON.parse(JSON.stringify(defaults));
                const svgText = await svgRes.text();

                const parser = new DOMParser();
                svgRoot = parser.parseFromString(svgText, 'image/svg+xml').documentElement;
                svgRoot.removeAttribute('width');
                svgRoot.removeAttribute('height');
                svgRoot.setAttribute('preserveAspectRatio', 'xMidYMid meet');

                container.innerHTML = '';
                container.appendChild(svgRoot);
                container.removeAttribute('aria-busy');

                paintFromState(svgRoot, state);
                attachPaintHandlers(svgRoot);

                setStatus('Ready. Click to paint; use Download/Load to manage JSON.');
            }

            function resetToDefaults() {
                if (!svgRoot) return;
                state = structuredClone ? structuredClone(defaults) : JSON.parse(JSON.stringify(defaults));
                svgRoot.querySelectorAll('[fill]').forEach(n => n.removeAttribute('fill'));
                svgRoot.querySelectorAll('[style]').forEach(n => { if (n.style && n.style.fill) n.style.fill = ''; });
                paintFromState(svgRoot, state);
                setStatus('Reset to defaults.');
            }

            function downloadCurrentJson() {
                const text = JSON.stringify(state, null, 2);
                const blob = new Blob([text], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'world.custom.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                setStatus('Downloaded world.custom.json');
            }

            function loadJsonFromFile(file) {
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const data = JSON.parse(e.target.result);
                        state = data;
                        svgRoot.querySelectorAll('[fill]').forEach(n => n.removeAttribute('fill'));
                        svgRoot.querySelectorAll('[style]').forEach(n => { if (n.style && n.style.fill) n.style.fill = ''; });
                        paintFromState(svgRoot, state);
                        setStatus('Loaded JSON.');
                    } catch (err) {
                        setStatus('Invalid JSON file.');
                        console.error(err);
                    }
                };
                reader.readAsText(file);
            }

            zoomInBtn.addEventListener('click', () => changeZoom(1.2));
            zoomOutBtn.addEventListener('click', () => changeZoom(1 / 1.2));
            resetViewBtn.addEventListener('click', () => {
                zoom = 1; panX = 0; panY = 0;
                applyTransform();
            });

            container.addEventListener('mousedown', e => {
                isDragging = true;
                dragStart = { x: e.clientX - panX, y: e.clientY - panY };
            });
            container.addEventListener('mousemove', e => {
                if (!isDragging) return;
                panX = e.clientX - dragStart.x;
                panY = e.clientY - dragStart.y;
                applyTransform();
            });
            window.addEventListener('mouseup', () => { isDragging = false; });

            container.addEventListener('wheel', e => {
                e.preventDefault();
                const factor = e.deltaY < 0 ? 1.2 : 1 / 1.2;
                changeZoom(factor, e.clientX, e.clientY);
            }, { passive: false });

            resetBtn.addEventListener('click', resetToDefaults);
            downloadBtn.addEventListener('click', downloadCurrentJson);
            uploadInput.addEventListener('change', e => {
                if (e.target.files && e.target.files[0]) loadJsonFromFile(e.target.files[0]);
            });

            try {
                await loadDefaultsAndSvg();
            } catch (e) {
                container.textContent = 'Failed to load map.';
                setStatus(String(e));
                console.error(e);
            }
        })();
    </script>
</body>

</html>